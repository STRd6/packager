<!DOCTYPE html>

<html>
<head>
  <title>packager</title>
  <meta http-equiv="content-type" content="text/html; charset=UTF-8">
  <meta name="viewport" content="width=device-width, target-densitydpi=160dpi, initial-scale=1.0; maximum-scale=1.0; user-scalable=0;">
  <link rel="stylesheet" media="all" href="http://strd6.github.io/cdn/parallel/docco.css" />
</head>
<body>
  <div id="container">
    <div id="background"></div>
    <ul class="sections">
        
        
        <li id="section-1">
            <div class="annotation">
              <div class="pilwrap">
                <a class="pilcrow" href="#section-1">&#182;</a>
              </div>
              <h1 id="packager">Packager</h1>

            </div>
            <div class="content"><pre><code class="lang-coffeescript">
</code></pre>
</div>
        </li>
        
        
        <li id="section-2">
            <div class="annotation">
              <div class="pilwrap">
                <a class="pilcrow" href="#section-2">&#182;</a>
              </div>
              <p>The main responsibilities will be bundling dependencies, and creating the
package.</p>

            </div>
            <div class="content"><pre><code class="lang-coffeescript">Packager =</code></pre>
</div>
        </li>
        
        
        <li id="section-3">
            <div class="annotation">
              <div class="pilwrap">
                <a class="pilcrow" href="#section-3">&#182;</a>
              </div>
              <p>If our string is an absolute URL then we assume that the server is CORS enabled
and we can make a cross origin request to collect the JSON data.</p>
<p>We also handle a Github repo dependency. Something like <code>STRd6/issues:master</code>.
This uses JSONP to load the package from the gh-pages branch of the given repo.</p>
<p><code>STRd6/issues:master</code> will be accessible at <code>http://strd6.github.io/issues/master.jsonp</code>.
The callback is the same as the repo info string: <code>window[&quot;STRd6/issues:master&quot;](... DATA ...)</code></p>
<p>Why all the madness? Github pages doesn&#39;t allow CORS right now, so we need to use
the JSONP hack to work around it. Because the files are static we can&#39;t allow the
server to generate a wrapper in response to our query string param so we need to
work out a unique one per file ahead of time. The <code>&lt;user&gt;/&lt;repo&gt;:&lt;ref&gt;</code> string is
unique for all our packages so we use it to determine the URL and name callback.</p>

            </div>
            <div class="content"><pre><code class="lang-coffeescript">  collectDependencies: (dependencies, cachedDependencies={}) -&gt;
    names = Object.keys(dependencies)

    Deferred.<span class="keyword">when</span>(names.map (name) -&gt;
      value = dependencies[name]

      <span class="keyword">if</span> <span class="keyword">typeof</span> value <span class="keyword">is</span> <span class="string">"string"</span>
        <span class="keyword">if</span> value.startsWith(<span class="string">"http"</span>)
          $.getJSON(value)
        <span class="keyword">else</span>
          <span class="keyword">if</span> (match = value.match(<span class="regexp">/([^\/]*)\/([^\:]*)\:(.*)/</span>))
            [callback, user, repo, branch] = match

            <span class="keyword">if</span> cachedDependency = lookupCached(cachedDependencies, <span class="string">"<span class="subst">#{user}</span>/<span class="subst">#{repo}</span>"</span>, branch)
              [cachedDependency]
            <span class="keyword">else</span>
              $.ajax
                url: <span class="string">"http://<span class="subst">#{user}</span>.github.io/<span class="subst">#{repo}</span>/<span class="subst">#{branch}</span>.jsonp"</span>
                dataType: <span class="string">"jsonp"</span>
                jsonpCallback: callback
                cache: <span class="literal">true</span>
          <span class="keyword">else</span>
            reject <span class="string">"""
              Failed to parse repository info string <span class="subst">#{value}</span>, be sure it's in the
              form `&lt;user&gt;/&lt;repo&gt;:&lt;ref&gt;` for example: `STRd6/issues:master`
              or `STRd6/editor:v0.9.1`
            """</span>
      <span class="keyword">else</span>
        reject <span class="string">"Can only handle url string dependencies right now"</span>
    ).<span class="keyword">then</span> (results) -&gt;
      bundledDependencies = {}

      names.each (name, i) -&gt;
        bundledDependencies[name] = results[i].first()

      <span class="keyword">return</span> bundledDependencies</code></pre>
</div>
        </li>
        
        
        <li id="section-4">
            <div class="annotation">
              <div class="pilwrap">
                <a class="pilcrow" href="#section-4">&#182;</a>
              </div>
              <p>Create the standalone components of this package. An html page that loads the
main entry point for demonstration purposes and a json package that can be
used as a dependency in other packages.</p>
<p>The html page is named <code>index.html</code> and is in the folder of the ref, or the root
if our ref is the default branch.</p>
<p>Docs are generated and placed in <code>docs</code> directory as a sibling to <code>index.html</code>.</p>
<p>An application manifest is served up as a sibling to <code>index.html</code> as well.</p>
<p>The <code>.js</code>, <code>.json</code>, and <code>.jsonp</code> build products are placed into the root level,
as siblings to the folder containing <code>index.html</code>. If this branch is the default
then these build products are placed as siblings to <code>index.html</code></p>

            </div>
            <div class="content"><pre><code class="lang-coffeescript">  standAlone: (pkg) -&gt;
    repository = pkg.repository
    branch = repository.branch

    <span class="keyword">if</span> branch <span class="keyword">is</span> repository.default_branch
      base = <span class="string">""</span>
    <span class="keyword">else</span>
      base = <span class="string">"<span class="subst">#{branch}</span>/"</span>

    files = []
    <span class="function"><span class="title">add</span></span> = (path, content) -&gt;
      files.push
        path: path
        content: content

    add <span class="string">"<span class="subst">#{base}</span>index.html"</span>, html(pkg)
    add <span class="string">"<span class="subst">#{base}</span>manifest.appcache"</span>, cacheManifest(pkg)

    json = JSON.stringify(pkg, <span class="literal">null</span>, <span class="number">2</span>)

    add <span class="string">"<span class="subst">#{branch}</span>.js"</span>, program(pkg)
    add <span class="string">"<span class="subst">#{branch}</span>.json"</span>, json
    add <span class="string">"<span class="subst">#{branch}</span>.jsonp"</span>, jsonpWrapper(repository, json)

    <span class="comment"># TODO: Add docs</span>

    <span class="keyword">return</span> files</code></pre>
</div>
        </li>
        
        
        <li id="section-5">
            <div class="annotation">
              <div class="pilwrap">
                <a class="pilcrow" href="#section-5">&#182;</a>
              </div>
              <p>Generates a standalone page for testing the app.</p>

            </div>
            <div class="content"><pre><code class="lang-coffeescript">  testScripts: (pkg) -&gt;
    {distribution} = pkg

    testProgram = Object.keys(distribution).select (path) -&gt;
      path.match <span class="regexp">/test\//</span>
    .map (testPath) -&gt;
      <span class="string">"require('./<span class="subst">#{testPath}</span>')"</span>
    .join <span class="string">"\n"</span>

    <span class="string">"""
      <span class="subst">#{dependencyScripts(pkg.remoteDependencies)}</span>
      &lt;script&gt;
        <span class="subst">#{packageWrapper(pkg, testProgram)}</span>
      &lt;\/script&gt;
    """</span>

module.exports = Packager</code></pre>
</div>
        </li>
        
        
        <li id="section-6">
            <div class="annotation">
              <div class="pilwrap">
                <a class="pilcrow" href="#section-6">&#182;</a>
              </div>
              <h2 id="helpers">Helpers</h2>

            </div>
            <div class="content"><pre><code class="lang-coffeescript">
</code></pre>
</div>
        </li>
        
        
        <li id="section-7">
            <div class="annotation">
              <div class="pilwrap">
                <a class="pilcrow" href="#section-7">&#182;</a>
              </div>
              <p>Create a rejected deferred with the given message.</p>

            </div>
            <div class="content"><pre><code class="lang-coffeescript"><span class="function"><span class="title">reject</span></span> = (message) -&gt;
  Deferred().reject(message)</code></pre>
</div>
        </li>
        
        
        <li id="section-8">
            <div class="annotation">
              <div class="pilwrap">
                <a class="pilcrow" href="#section-8">&#182;</a>
              </div>
              <p>A standalone html page for a package.</p>

            </div>
            <div class="content"><pre><code class="lang-coffeescript"><span class="function"><span class="title">html</span></span> = (pkg) -&gt;
  <span class="string">"""
    &lt;!DOCTYPE html&gt;
    &lt;html manifest="manifest.appcache?<span class="subst">#{+<span class="keyword">new</span> Date}</span>"&gt;
    &lt;head&gt;
    &lt;meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /&gt;
    <span class="subst">#{dependencyScripts(pkg.remoteDependencies)}</span>
    &lt;/head&gt;
    &lt;body&gt;
    &lt;script&gt;
    <span class="subst">#{packageWrapper(pkg, "require('./#{pkg.entryPoint}</span>')")}
    &lt;\/script&gt;
    &lt;/body&gt;
    &lt;/html&gt;
  """</span></code></pre>
</div>
        </li>
        
        
        <li id="section-9">
            <div class="annotation">
              <div class="pilwrap">
                <a class="pilcrow" href="#section-9">&#182;</a>
              </div>
              <p>An HTML5 cache manifest for a package.</p>

            </div>
            <div class="content"><pre><code class="lang-coffeescript"><span class="function"><span class="title">cacheManifest</span></span> = (pkg) -&gt;
  <span class="string">"""
    CACHE MANIFEST
    # <span class="subst">#{+ <span class="keyword">new</span> Date}</span>

    CACHE:
    index.html
    <span class="subst">#{(pkg.remoteDependencies <span class="keyword">or</span> []).join("\n")}</span>

    NETWORK:
    https://*
    http://*
    *
  """</span></code></pre>
</div>
        </li>
        
        
        <li id="section-10">
            <div class="annotation">
              <div class="pilwrap">
                <a class="pilcrow" href="#section-10">&#182;</a>
              </div>
              <p><code>makeScript</code> returns a string representation of a script tag that has a src
attribute.</p>

            </div>
            <div class="content"><pre><code class="lang-coffeescript"><span class="function"><span class="title">makeScript</span></span> = (src) -&gt;
  script = document.createElement(<span class="string">"script"</span>)
  script.src = src

  <span class="keyword">return</span> script.outerHTML</code></pre>
</div>
        </li>
        
        
        <li id="section-11">
            <div class="annotation">
              <div class="pilwrap">
                <a class="pilcrow" href="#section-11">&#182;</a>
              </div>
              <p><code>dependencyScripts</code> returns a string containing the script tags that are
the remote script dependencies of this build.</p>

            </div>
            <div class="content"><pre><code class="lang-coffeescript"><span class="function"><span class="title">dependencyScripts</span></span> = (remoteDependencies=[]) -&gt;
  remoteDependencies.map(makeScript).join(<span class="string">"\n"</span>)</code></pre>
</div>
        </li>
        
        
        <li id="section-12">
            <div class="annotation">
              <div class="pilwrap">
                <a class="pilcrow" href="#section-12">&#182;</a>
              </div>
              <p>A standalone JS program for the package. Does not use <code>require</code> and is only
suitable for script style dependencies.</p>

            </div>
            <div class="content"><pre><code class="lang-coffeescript"><span class="function"><span class="title">program</span></span> = ({distribution, entryPoint}) -&gt;
  <span class="keyword">if</span> main = distribution[entryPoint]
    <span class="keyword">return</span> main.content
  <span class="keyword">else</span>
    <span class="comment"># TODO: We should emit some kind of user-visible warning</span>
    console.warn <span class="string">"Entry point <span class="subst">#{entryPoint}</span> not found."</span>

    <span class="keyword">return</span> <span class="string">""</span></code></pre>
</div>
        </li>
        
        
        <li id="section-13">
            <div class="annotation">
              <div class="pilwrap">
                <a class="pilcrow" href="#section-13">&#182;</a>
              </div>
              <p>Wraps the given data in a JSONP function wrapper. This allows us to host our
packages on Github pages and get around any same origin issues by using JSONP.</p>

            </div>
            <div class="content"><pre><code class="lang-coffeescript"><span class="function"><span class="title">jsonpWrapper</span></span> = (repository, data) -&gt;
  <span class="string">"""
    window["<span class="subst">#{repository.full_name}</span>:<span class="subst">#{repository.branch}</span>"](<span class="subst">#{data}</span>);
  """</span></code></pre>
</div>
        </li>
        
        
        <li id="section-14">
            <div class="annotation">
              <div class="pilwrap">
                <a class="pilcrow" href="#section-14">&#182;</a>
              </div>
              <p>Wrap code in a closure that provides the package and a require function. This
can be used for generating standalone HTML pages, scripts, and tests.</p>

            </div>
            <div class="content"><pre><code class="lang-coffeescript"><span class="function"><span class="title">packageWrapper</span></span> = (pkg, code) -&gt;
  <span class="string">"""
    ;(function(PACKAGE) {
    var require = Require.generateFor(PACKAGE);
    <span class="subst">#{code}</span>
    })(<span class="subst">#{JSON.stringify(pkg, <span class="literal">null</span>, <span class="number">2</span>)}</span>);
  """</span></code></pre>
</div>
        </li>
        
        
        <li id="section-15">
            <div class="annotation">
              <div class="pilwrap">
                <a class="pilcrow" href="#section-15">&#182;</a>
              </div>
              <p>Lookup a package from a cached list of packages.</p>

            </div>
            <div class="content"><pre><code class="lang-coffeescript"><span class="function"><span class="title">lookupCached</span></span> = (cache, fullName, branch) -&gt;
  name = Object.keys(cache).select (key) -&gt;
    repository = cache[key].repository

    console.log <span class="string">"checking <span class="subst">#{fullName}</span>:<span class="subst">#{branch}</span> vs <span class="subst">#{repository.full_name}</span>"</span>

    repository.full_name <span class="keyword">is</span> fullName <span class="keyword">and</span> repository.branch <span class="keyword">is</span> branch
  .first()

  console.log name

  <span class="keyword">if</span> name
    cache[name]</code></pre>
</div>
        </li>
        
    </ul>
  </div>
  <script src="//code.jquery.com/jquery-1.10.1.min.js"></script>
<script src="//cdnjs.cloudflare.com/ajax/libs/coffee-script/1.6.3/coffee-script.min.js"></script>
<script src="http://strd6.github.io/require/v0.2.1.js"></script>
<script src="http://strd6.github.io/interactive/v0.8.0.js"></script>
<script src="http://strd6.github.io/tempest/javascripts/envweb.js"></script>
<script src="http://strd6.github.io/require/v0.2.2.js"></script>
<script>
  (function(pkg) {
    // Expose a require for our package so scripts can access our modules
    window.require = Require.generateFor(pkg);
  })({
  "version": "0.3.1",
  "source": {
    "LICENSE": {
      "path": "LICENSE",
      "mode": "100644",
      "content": "The MIT License (MIT)\n\nCopyright (c) 2013 Daniel X Moore\n\nPermission is hereby granted, free of charge, to any person obtaining a copy of\nthis software and associated documentation files (the \"Software\"), to deal in\nthe Software without restriction, including without limitation the rights to\nuse, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of\nthe Software, and to permit persons to whom the Software is furnished to do so,\nsubject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS\nFOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR\nCOPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER\nIN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN\nCONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n",
      "type": "blob"
    },
    "README.md": {
      "path": "README.md",
      "mode": "100644",
      "content": "packager\n========\n\nCreate standalone build products for web packages\n",
      "type": "blob"
    },
    "packager.coffee.md": {
      "path": "packager.coffee.md",
      "mode": "100644",
      "content": "Packager\n========\n\nThe main responsibilities will be bundling dependencies, and creating the\npackage.\n\n    Packager =\n\nIf our string is an absolute URL then we assume that the server is CORS enabled\nand we can make a cross origin request to collect the JSON data.\n\nWe also handle a Github repo dependency. Something like `STRd6/issues:master`.\nThis uses JSONP to load the package from the gh-pages branch of the given repo.\n\n`STRd6/issues:master` will be accessible at `http://strd6.github.io/issues/master.jsonp`.\nThe callback is the same as the repo info string: `window[\"STRd6/issues:master\"](... DATA ...)`\n\nWhy all the madness? Github pages doesn't allow CORS right now, so we need to use\nthe JSONP hack to work around it. Because the files are static we can't allow the\nserver to generate a wrapper in response to our query string param so we need to\nwork out a unique one per file ahead of time. The `<user>/<repo>:<ref>` string is\nunique for all our packages so we use it to determine the URL and name callback.\n\n      collectDependencies: (dependencies, cachedDependencies={}) ->\n        names = Object.keys(dependencies)\n\n        Deferred.when(names.map (name) ->\n          value = dependencies[name]\n\n          if typeof value is \"string\"\n            if value.startsWith(\"http\")\n              $.getJSON(value)\n            else\n              if (match = value.match(/([^\\/]*)\\/([^\\:]*)\\:(.*)/))\n                [callback, user, repo, branch] = match\n\n                if cachedDependency = lookupCached(cachedDependencies, \"#{user}/#{repo}\", branch)\n                  [cachedDependency]\n                else\n                  $.ajax\n                    url: \"http://#{user}.github.io/#{repo}/#{branch}.jsonp\"\n                    dataType: \"jsonp\"\n                    jsonpCallback: callback\n                    cache: true\n              else\n                reject \"\"\"\n                  Failed to parse repository info string #{value}, be sure it's in the\n                  form `<user>/<repo>:<ref>` for example: `STRd6/issues:master`\n                  or `STRd6/editor:v0.9.1`\n                \"\"\"\n          else\n            reject \"Can only handle url string dependencies right now\"\n        ).then (results) ->\n          bundledDependencies = {}\n\n          names.each (name, i) ->\n            bundledDependencies[name] = results[i].first()\n\n          return bundledDependencies\n\nCreate the standalone components of this package. An html page that loads the\nmain entry point for demonstration purposes and a json package that can be\nused as a dependency in other packages.\n\nThe html page is named `index.html` and is in the folder of the ref, or the root\nif our ref is the default branch.\n\nDocs are generated and placed in `docs` directory as a sibling to `index.html`.\n\nAn application manifest is served up as a sibling to `index.html` as well.\n\nThe `.js`, `.json`, and `.jsonp` build products are placed into the root level,\nas siblings to the folder containing `index.html`. If this branch is the default\nthen these build products are placed as siblings to `index.html`\n\n      standAlone: (pkg) ->\n        repository = pkg.repository\n        branch = repository.branch\n\n        if branch is repository.default_branch\n          base = \"\"\n        else\n          base = \"#{branch}/\"\n\n        files = []\n        add = (path, content) ->\n          files.push\n            path: path\n            content: content\n\n        add \"#{base}index.html\", html(pkg)\n        add \"#{base}manifest.appcache\", cacheManifest(pkg)\n\n        json = JSON.stringify(pkg, null, 2)\n\n        add \"#{branch}.js\", program(pkg)\n        add \"#{branch}.json\", json\n        add \"#{branch}.jsonp\", jsonpWrapper(repository, json)\n\n        # TODO: Add docs\n\n        return files\n\nGenerates a standalone page for testing the app.\n\n      testScripts: (pkg) ->\n        {distribution} = pkg\n\n        testProgram = Object.keys(distribution).select (path) ->\n          path.match /test\\//\n        .map (testPath) ->\n          \"require('./#{testPath}')\"\n        .join \"\\n\"\n\n        \"\"\"\n          #{dependencyScripts(pkg.remoteDependencies)}\n          <script>\n            #{packageWrapper(pkg, testProgram)}\n          <\\/script>\n        \"\"\"\n\n    module.exports = Packager\n\nHelpers\n-------\n\nCreate a rejected deferred with the given message.\n\n    reject = (message) ->\n      Deferred().reject(message)\n\nA standalone html page for a package.\n\n    html = (pkg) ->\n      \"\"\"\n        <!DOCTYPE html>\n        <html manifest=\"manifest.appcache?#{+new Date}\">\n        <head>\n        <meta http-equiv=\"Content-Type\" content=\"text/html; charset=UTF-8\" />\n        #{dependencyScripts(pkg.remoteDependencies)}\n        </head>\n        <body>\n        <script>\n        #{packageWrapper(pkg, \"require('./#{pkg.entryPoint}')\")}\n        <\\/script>\n        </body>\n        </html>\n      \"\"\"\n\nAn HTML5 cache manifest for a package.\n\n    cacheManifest = (pkg) ->\n      \"\"\"\n        CACHE MANIFEST\n        # #{+ new Date}\n\n        CACHE:\n        index.html\n        #{(pkg.remoteDependencies or []).join(\"\\n\")}\n\n        NETWORK:\n        https://*\n        http://*\n        *\n      \"\"\"\n\n`makeScript` returns a string representation of a script tag that has a src\nattribute.\n\n    makeScript = (src) ->\n      script = document.createElement(\"script\")\n      script.src = src\n\n      return script.outerHTML\n\n`dependencyScripts` returns a string containing the script tags that are\nthe remote script dependencies of this build.\n\n    dependencyScripts = (remoteDependencies=[]) ->\n      remoteDependencies.map(makeScript).join(\"\\n\")\n\nA standalone JS program for the package. Does not use `require` and is only\nsuitable for script style dependencies.\n\n    program = ({distribution, entryPoint}) ->\n      if main = distribution[entryPoint]\n        return main.content\n      else\n        # TODO: We should emit some kind of user-visible warning\n        console.warn \"Entry point #{entryPoint} not found.\"\n\n        return \"\"\n\nWraps the given data in a JSONP function wrapper. This allows us to host our\npackages on Github pages and get around any same origin issues by using JSONP.\n\n    jsonpWrapper = (repository, data) ->\n      \"\"\"\n        window[\"#{repository.full_name}:#{repository.branch}\"](#{data});\n      \"\"\"\n\nWrap code in a closure that provides the package and a require function. This\ncan be used for generating standalone HTML pages, scripts, and tests.\n\n    packageWrapper = (pkg, code) ->\n      \"\"\"\n        ;(function(PACKAGE) {\n        var require = Require.generateFor(PACKAGE);\n        #{code}\n        })(#{JSON.stringify(pkg, null, 2)});\n      \"\"\"\n\nLookup a package from a cached list of packages.\n\n    lookupCached = (cache, fullName, branch) ->\n      name = Object.keys(cache).select (key) ->\n        repository = cache[key].repository\n        \n        console.log \"checking #{fullName}:#{branch} vs #{repository.full_name}\"\n\n        repository.full_name is fullName and repository.branch is branch\n      .first()\n\n      console.log name\n\n      if name\n        cache[name]\n",
      "type": "blob"
    },
    "pixie.cson": {
      "path": "pixie.cson",
      "mode": "100644",
      "content": "version: \"0.3.1\"\nentryPoint: \"packager\"\nremoteDependencies: [\n  \"//code.jquery.com/jquery-1.10.1.min.js\"\n  \"http://strd6.github.io/tempest/javascripts/envweb.js\"\n  \"http://strd6.github.io/require/v0.2.2.js\"\n]\n",
      "type": "blob"
    },
    "test/packager.coffee": {
      "path": "test/packager.coffee",
      "mode": "100644",
      "content": "Packager = require(\"../packager\")\n\ndescribe \"Packager\", ->\n  it \"should exist\", ->\n    assert Packager\n\n  it \"should be able to create a standalone html page\", ->\n    assert Packager.standAlone(PACKAGE)\n",
      "type": "blob"
    }
  },
  "distribution": {
    "packager": {
      "path": "packager",
      "content": "(function() {\n  var Packager, cacheManifest, dependencyScripts, html, jsonpWrapper, lookupCached, makeScript, packageWrapper, program, reject;\n\n  Packager = {\n    collectDependencies: function(dependencies, cachedDependencies) {\n      var names;\n      if (cachedDependencies == null) {\n        cachedDependencies = {};\n      }\n      names = Object.keys(dependencies);\n      return Deferred.when(names.map(function(name) {\n        var branch, cachedDependency, callback, match, repo, user, value;\n        value = dependencies[name];\n        if (typeof value === \"string\") {\n          if (value.startsWith(\"http\")) {\n            return $.getJSON(value);\n          } else {\n            if ((match = value.match(/([^\\/]*)\\/([^\\:]*)\\:(.*)/))) {\n              callback = match[0], user = match[1], repo = match[2], branch = match[3];\n              if (cachedDependency = lookupCached(cachedDependencies, \"\" + user + \"/\" + repo, branch)) {\n                return [cachedDependency];\n              } else {\n                return $.ajax({\n                  url: \"http://\" + user + \".github.io/\" + repo + \"/\" + branch + \".jsonp\",\n                  dataType: \"jsonp\",\n                  jsonpCallback: callback,\n                  cache: true\n                });\n              }\n            } else {\n              return reject(\"Failed to parse repository info string \" + value + \", be sure it's in the\\nform `<user>/<repo>:<ref>` for example: `STRd6/issues:master`\\nor `STRd6/editor:v0.9.1`\");\n            }\n          }\n        } else {\n          return reject(\"Can only handle url string dependencies right now\");\n        }\n      })).then(function(results) {\n        var bundledDependencies;\n        bundledDependencies = {};\n        names.each(function(name, i) {\n          return bundledDependencies[name] = results[i].first();\n        });\n        return bundledDependencies;\n      });\n    },\n    standAlone: function(pkg) {\n      var add, base, branch, files, json, repository;\n      repository = pkg.repository;\n      branch = repository.branch;\n      if (branch === repository.default_branch) {\n        base = \"\";\n      } else {\n        base = \"\" + branch + \"/\";\n      }\n      files = [];\n      add = function(path, content) {\n        return files.push({\n          path: path,\n          content: content\n        });\n      };\n      add(\"\" + base + \"index.html\", html(pkg));\n      add(\"\" + base + \"manifest.appcache\", cacheManifest(pkg));\n      json = JSON.stringify(pkg, null, 2);\n      add(\"\" + branch + \".js\", program(pkg));\n      add(\"\" + branch + \".json\", json);\n      add(\"\" + branch + \".jsonp\", jsonpWrapper(repository, json));\n      return files;\n    },\n    testScripts: function(pkg) {\n      var distribution, testProgram;\n      distribution = pkg.distribution;\n      testProgram = Object.keys(distribution).select(function(path) {\n        return path.match(/test\\//);\n      }).map(function(testPath) {\n        return \"require('./\" + testPath + \"')\";\n      }).join(\"\\n\");\n      return \"\" + (dependencyScripts(pkg.remoteDependencies)) + \"\\n<script>\\n  \" + (packageWrapper(pkg, testProgram)) + \"\\n<\\/script>\";\n    }\n  };\n\n  module.exports = Packager;\n\n  reject = function(message) {\n    return Deferred().reject(message);\n  };\n\n  html = function(pkg) {\n    return \"<!DOCTYPE html>\\n<html manifest=\\\"manifest.appcache?\" + (+(new Date)) + \"\\\">\\n<head>\\n<meta http-equiv=\\\"Content-Type\\\" content=\\\"text/html; charset=UTF-8\\\" />\\n\" + (dependencyScripts(pkg.remoteDependencies)) + \"\\n</head>\\n<body>\\n<script>\\n\" + (packageWrapper(pkg, \"require('./\" + pkg.entryPoint + \"')\")) + \"\\n<\\/script>\\n</body>\\n</html>\";\n  };\n\n  cacheManifest = function(pkg) {\n    return \"CACHE MANIFEST\\n# \" + (+(new Date)) + \"\\n\\nCACHE:\\nindex.html\\n\" + ((pkg.remoteDependencies || []).join(\"\\n\")) + \"\\n\\nNETWORK:\\nhttps://*\\nhttp://*\\n*\";\n  };\n\n  makeScript = function(src) {\n    var script;\n    script = document.createElement(\"script\");\n    script.src = src;\n    return script.outerHTML;\n  };\n\n  dependencyScripts = function(remoteDependencies) {\n    if (remoteDependencies == null) {\n      remoteDependencies = [];\n    }\n    return remoteDependencies.map(makeScript).join(\"\\n\");\n  };\n\n  program = function(_arg) {\n    var distribution, entryPoint, main;\n    distribution = _arg.distribution, entryPoint = _arg.entryPoint;\n    if (main = distribution[entryPoint]) {\n      return main.content;\n    } else {\n      console.warn(\"Entry point \" + entryPoint + \" not found.\");\n      return \"\";\n    }\n  };\n\n  jsonpWrapper = function(repository, data) {\n    return \"window[\\\"\" + repository.full_name + \":\" + repository.branch + \"\\\"](\" + data + \");\";\n  };\n\n  packageWrapper = function(pkg, code) {\n    return \";(function(PACKAGE) {\\nvar require = Require.generateFor(PACKAGE);\\n\" + code + \"\\n})(\" + (JSON.stringify(pkg, null, 2)) + \");\";\n  };\n\n  lookupCached = function(cache, fullName, branch) {\n    var name;\n    name = Object.keys(cache).select(function(key) {\n      var repository;\n      repository = cache[key].repository;\n      console.log(\"checking \" + fullName + \":\" + branch + \" vs \" + repository.full_name);\n      return repository.full_name === fullName && repository.branch === branch;\n    }).first();\n    console.log(name);\n    if (name) {\n      return cache[name];\n    }\n  };\n\n}).call(this);\n\n//# sourceURL=packager.coffee",
      "type": "blob"
    },
    "pixie": {
      "path": "pixie",
      "content": "module.exports = {\"version\":\"0.3.1\",\"entryPoint\":\"packager\",\"remoteDependencies\":[\"//code.jquery.com/jquery-1.10.1.min.js\",\"http://strd6.github.io/tempest/javascripts/envweb.js\",\"http://strd6.github.io/require/v0.2.2.js\"]};",
      "type": "blob"
    },
    "test/packager": {
      "path": "test/packager",
      "content": "(function() {\n  var Packager;\n\n  Packager = require(\"../packager\");\n\n  describe(\"Packager\", function() {\n    it(\"should exist\", function() {\n      return assert(Packager);\n    });\n    return it(\"should be able to create a standalone html page\", function() {\n      return assert(Packager.standAlone(PACKAGE));\n    });\n  });\n\n}).call(this);\n\n//# sourceURL=test/packager.coffee",
      "type": "blob"
    }
  },
  "entryPoint": "packager",
  "dependencies": {},
  "remoteDependencies": [
    "//code.jquery.com/jquery-1.10.1.min.js",
    "http://strd6.github.io/tempest/javascripts/envweb.js",
    "http://strd6.github.io/require/v0.2.2.js"
  ],
  "repository": {
    "id": 13223375,
    "name": "packager",
    "full_name": "STRd6/packager",
    "owner": {
      "login": "STRd6",
      "id": 18894,
      "avatar_url": "https://1.gravatar.com/avatar/33117162fff8a9cf50544a604f60c045?d=https%3A%2F%2Fidenticons.github.com%2F39df222bffe39629d904e4883eabc654.png",
      "gravatar_id": "33117162fff8a9cf50544a604f60c045",
      "url": "https://api.github.com/users/STRd6",
      "html_url": "https://github.com/STRd6",
      "followers_url": "https://api.github.com/users/STRd6/followers",
      "following_url": "https://api.github.com/users/STRd6/following{/other_user}",
      "gists_url": "https://api.github.com/users/STRd6/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/STRd6/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/STRd6/subscriptions",
      "organizations_url": "https://api.github.com/users/STRd6/orgs",
      "repos_url": "https://api.github.com/users/STRd6/repos",
      "events_url": "https://api.github.com/users/STRd6/events{/privacy}",
      "received_events_url": "https://api.github.com/users/STRd6/received_events",
      "type": "User"
    },
    "private": false,
    "html_url": "https://github.com/STRd6/packager",
    "description": "Create standalone build products for web packages",
    "fork": false,
    "url": "https://api.github.com/repos/STRd6/packager",
    "forks_url": "https://api.github.com/repos/STRd6/packager/forks",
    "keys_url": "https://api.github.com/repos/STRd6/packager/keys{/key_id}",
    "collaborators_url": "https://api.github.com/repos/STRd6/packager/collaborators{/collaborator}",
    "teams_url": "https://api.github.com/repos/STRd6/packager/teams",
    "hooks_url": "https://api.github.com/repos/STRd6/packager/hooks",
    "issue_events_url": "https://api.github.com/repos/STRd6/packager/issues/events{/number}",
    "events_url": "https://api.github.com/repos/STRd6/packager/events",
    "assignees_url": "https://api.github.com/repos/STRd6/packager/assignees{/user}",
    "branches_url": "https://api.github.com/repos/STRd6/packager/branches{/branch}",
    "tags_url": "https://api.github.com/repos/STRd6/packager/tags",
    "blobs_url": "https://api.github.com/repos/STRd6/packager/git/blobs{/sha}",
    "git_tags_url": "https://api.github.com/repos/STRd6/packager/git/tags{/sha}",
    "git_refs_url": "https://api.github.com/repos/STRd6/packager/git/refs{/sha}",
    "trees_url": "https://api.github.com/repos/STRd6/packager/git/trees{/sha}",
    "statuses_url": "https://api.github.com/repos/STRd6/packager/statuses/{sha}",
    "languages_url": "https://api.github.com/repos/STRd6/packager/languages",
    "stargazers_url": "https://api.github.com/repos/STRd6/packager/stargazers",
    "contributors_url": "https://api.github.com/repos/STRd6/packager/contributors",
    "subscribers_url": "https://api.github.com/repos/STRd6/packager/subscribers",
    "subscription_url": "https://api.github.com/repos/STRd6/packager/subscription",
    "commits_url": "https://api.github.com/repos/STRd6/packager/commits{/sha}",
    "git_commits_url": "https://api.github.com/repos/STRd6/packager/git/commits{/sha}",
    "comments_url": "https://api.github.com/repos/STRd6/packager/comments{/number}",
    "issue_comment_url": "https://api.github.com/repos/STRd6/packager/issues/comments/{number}",
    "contents_url": "https://api.github.com/repos/STRd6/packager/contents/{+path}",
    "compare_url": "https://api.github.com/repos/STRd6/packager/compare/{base}...{head}",
    "merges_url": "https://api.github.com/repos/STRd6/packager/merges",
    "archive_url": "https://api.github.com/repos/STRd6/packager/{archive_format}{/ref}",
    "downloads_url": "https://api.github.com/repos/STRd6/packager/downloads",
    "issues_url": "https://api.github.com/repos/STRd6/packager/issues{/number}",
    "pulls_url": "https://api.github.com/repos/STRd6/packager/pulls{/number}",
    "milestones_url": "https://api.github.com/repos/STRd6/packager/milestones{/number}",
    "notifications_url": "https://api.github.com/repos/STRd6/packager/notifications{?since,all,participating}",
    "labels_url": "https://api.github.com/repos/STRd6/packager/labels{/name}",
    "created_at": "2013-09-30T18:28:31Z",
    "updated_at": "2013-10-03T23:00:39Z",
    "pushed_at": "2013-10-03T23:00:39Z",
    "git_url": "git://github.com/STRd6/packager.git",
    "ssh_url": "git@github.com:STRd6/packager.git",
    "clone_url": "https://github.com/STRd6/packager.git",
    "svn_url": "https://github.com/STRd6/packager",
    "homepage": null,
    "size": 1884,
    "watchers_count": 0,
    "language": "CoffeeScript",
    "has_issues": true,
    "has_downloads": true,
    "has_wiki": true,
    "forks_count": 0,
    "mirror_url": null,
    "open_issues_count": 0,
    "forks": 0,
    "open_issues": 0,
    "watchers": 0,
    "master_branch": "master",
    "default_branch": "master",
    "permissions": {
      "admin": true,
      "push": true,
      "pull": true
    },
    "network_count": 0,
    "branch": "v0.3.1-alpha.9",
    "defaultBranch": "master",
    "includedModules": [
      "Bindable"
    ]
  },
  "progenitor": {
    "url": "http://strd6.github.io/editor/"
  }
});
</script>
</body>
</html>